export declare const File: {
    new (fileBits: BlobPart[], fileName: string, options?: FilePropertyBag | undefined): File;
    prototype: File;
} | {
    new (value?: any): {
        constructor: Function;
        toString(): string;
        toLocaleString(): string;
        valueOf(): Object;
        hasOwnProperty(v: PropertyKey): boolean;
        isPrototypeOf(v: Object): boolean;
        propertyIsEnumerable(v: PropertyKey): boolean;
    };
    getPrototypeOf(o: any): any;
    getOwnPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined;
    getOwnPropertyNames(o: any): string[];
    create(o: object | null): any;
    create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;
    defineProperty<T>(o: T, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): T;
    defineProperties<T_1>(o: T_1, properties: PropertyDescriptorMap & ThisType<any>): T_1;
    seal<T_2>(o: T_2): T_2;
    freeze<T_3 extends Function>(f: T_3): T_3;
    freeze<T_4 extends {
        [idx: string]: object | U | null | undefined;
    }, U extends string | number | bigint | boolean | symbol>(o: T_4): Readonly<T_4>;
    freeze<T_5>(o: T_5): Readonly<T_5>;
    preventExtensions<T_6>(o: T_6): T_6;
    isSealed(o: any): boolean;
    isFrozen(o: any): boolean;
    isExtensible(o: any): boolean;
    keys(o: object): string[];
    keys(o: {}): string[];
    assign<T_7 extends {}, U_1>(target: T_7, source: U_1): T_7 & U_1;
    assign<T_8 extends {}, U_2, V>(target: T_8, source1: U_2, source2: V): T_8 & U_2 & V;
    assign<T_9 extends {}, U_3, V_1, W>(target: T_9, source1: U_3, source2: V_1, source3: W): T_9 & U_3 & V_1 & W;
    assign(target: object, ...sources: any[]): any;
    getOwnPropertySymbols(o: any): symbol[];
    is(value1: any, value2: any): boolean;
    setPrototypeOf(o: any, proto: object | null): any;
    values<T_10>(o: {
        [s: string]: T_10;
    } | ArrayLike<T_10>): T_10[];
    values(o: {}): any[];
    entries<T_11>(o: {
        [s: string]: T_11;
    } | ArrayLike<T_11>): [string, T_11][];
    entries(o: {}): [string, any][];
    getOwnPropertyDescriptors<T_12>(o: T_12): { [P in keyof T_12]: TypedPropertyDescriptor<T_12[P]>; } & {
        [x: string]: PropertyDescriptor;
    };
    fromEntries<T_13 = any>(entries: Iterable<readonly [PropertyKey, T_13]>): {
        [k: string]: T_13;
    };
    fromEntries(entries: Iterable<readonly any[]>): any;
};
declare const CFormInput: import("vue").DefineComponent<{
    /**
     * Toggle the disabled state for the component.
     */
    disabled: {
        type: BooleanConstructor;
        required: false;
    };
    /**
     * Provide valuable, actionable feedback.
     *
     * @since 4.3.0
     */
    feedback: {
        type: StringConstructor;
    };
    /**
     * Provide valuable, actionable feedback.
     *
     * @since 4.3.0
     */
    feedbackInvalid: {
        type: StringConstructor;
    };
    /**
     * Provide valuable, actionable invalid feedback when using standard HTML form validation which applied two CSS pseudo-classes, `:invalid` and `:valid`.
     *
     * @since 4.3.0
     */
    feedbackValid: {
        type: StringConstructor;
    };
    /**
     * Provide valuable, actionable valid feedback when using standard HTML form validation which applied two CSS pseudo-classes, `:invalid` and `:valid`.
     *
     * @since 4.3.0
     */
    floatingLabel: {
        type: StringConstructor;
    };
    /**
     * The id global attribute defines an identifier (ID) that must be unique in the whole document.
     */
    id: {
        type: StringConstructor;
    };
    /**
     * Set component validation state to invalid.
     */
    invalid: BooleanConstructor;
    /**
     * Add a caption for a component.
     *
     * @since 4.3.0
     */
    label: {
        type: StringConstructor;
    };
    /**
     * The default name for a value passed using v-model.
     */
    modelValue: {
        type: (NumberConstructor | StringConstructor | {
            new (fileBits: BlobPart[], fileName: string, options?: FilePropertyBag | undefined): File;
            prototype: File;
        } | {
            new (value?: any): {
                constructor: Function;
                toString(): string;
                toLocaleString(): string;
                valueOf(): Object;
                hasOwnProperty(v: PropertyKey): boolean;
                isPrototypeOf(v: Object): boolean;
                propertyIsEnumerable(v: PropertyKey): boolean;
            };
            getPrototypeOf(o: any): any;
            getOwnPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined;
            getOwnPropertyNames(o: any): string[];
            create(o: object | null): any;
            create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;
            defineProperty<T>(o: T, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): T;
            defineProperties<T_1>(o: T_1, properties: PropertyDescriptorMap & ThisType<any>): T_1;
            seal<T_2>(o: T_2): T_2;
            freeze<T_3 extends Function>(f: T_3): T_3;
            freeze<T_4 extends {
                [idx: string]: object | U | null | undefined;
            }, U extends string | number | bigint | boolean | symbol>(o: T_4): Readonly<T_4>;
            freeze<T_5>(o: T_5): Readonly<T_5>;
            preventExtensions<T_6>(o: T_6): T_6;
            isSealed(o: any): boolean;
            isFrozen(o: any): boolean;
            isExtensible(o: any): boolean;
            keys(o: object): string[];
            keys(o: {}): string[];
            assign<T_7 extends {}, U_1>(target: T_7, source: U_1): T_7 & U_1;
            assign<T_8 extends {}, U_2, V>(target: T_8, source1: U_2, source2: V): T_8 & U_2 & V;
            assign<T_9 extends {}, U_3, V_1, W>(target: T_9, source1: U_3, source2: V_1, source3: W): T_9 & U_3 & V_1 & W;
            assign(target: object, ...sources: any[]): any;
            getOwnPropertySymbols(o: any): symbol[];
            is(value1: any, value2: any): boolean;
            setPrototypeOf(o: any, proto: object | null): any;
            values<T_10>(o: {
                [s: string]: T_10;
            } | ArrayLike<T_10>): T_10[];
            values(o: {}): any[];
            entries<T_11>(o: {
                [s: string]: T_11;
            } | ArrayLike<T_11>): [string, T_11][];
            entries(o: {}): [string, any][];
            getOwnPropertyDescriptors<T_12>(o: T_12): { [P in keyof T_12]: TypedPropertyDescriptor<T_12[P]>; } & {
                [x: string]: PropertyDescriptor;
            };
            fromEntries<T_13 = any>(entries: Iterable<readonly [PropertyKey, T_13]>): {
                [k: string]: T_13;
            };
            fromEntries(entries: Iterable<readonly any[]>): any;
        })[];
        default: undefined;
    };
    /**
     * Render the component styled as plain text. Removes the default form field styling and preserve the correct margin and padding. Recommend to use only along side `readonly`.
     */
    plainText: {
        type: BooleanConstructor;
        required: false;
    };
    /**
     * Toggle the readonly state for the component.
     */
    readonly: {
        type: BooleanConstructor;
        required: false;
    };
    /**
     * Size the component small or large.
     *
     * @values 'sm' | 'lg'
     */
    size: {
        type: StringConstructor;
        validator: (value: string) => boolean;
    };
    /**
     * Add helper text to the component.
     *
     * @since 4.3.0
     */
    text: {
        type: StringConstructor;
    };
    /**
     * Display validation feedback in a styled tooltip.
     *
     * @since 4.3.0
     */
    tooltipFeedback: BooleanConstructor;
    /**
     * Specifies the type of component.
     *
     * @values 'color' | 'file' | 'text' | string
     */
    type: {
        type: StringConstructor;
        default: string;
    };
    /**
     * Set component validation state to valid.
     */
    valid: BooleanConstructor;
}, () => import("vue").VNode<import("vue").RendererNode, import("vue").RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, ("change" | "input" | "update:modelValue")[], "change" | "input" | "update:modelValue", import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, Readonly<import("vue").ExtractPropTypes<{
    /**
     * Toggle the disabled state for the component.
     */
    disabled: {
        type: BooleanConstructor;
        required: false;
    };
    /**
     * Provide valuable, actionable feedback.
     *
     * @since 4.3.0
     */
    feedback: {
        type: StringConstructor;
    };
    /**
     * Provide valuable, actionable feedback.
     *
     * @since 4.3.0
     */
    feedbackInvalid: {
        type: StringConstructor;
    };
    /**
     * Provide valuable, actionable invalid feedback when using standard HTML form validation which applied two CSS pseudo-classes, `:invalid` and `:valid`.
     *
     * @since 4.3.0
     */
    feedbackValid: {
        type: StringConstructor;
    };
    /**
     * Provide valuable, actionable valid feedback when using standard HTML form validation which applied two CSS pseudo-classes, `:invalid` and `:valid`.
     *
     * @since 4.3.0
     */
    floatingLabel: {
        type: StringConstructor;
    };
    /**
     * The id global attribute defines an identifier (ID) that must be unique in the whole document.
     */
    id: {
        type: StringConstructor;
    };
    /**
     * Set component validation state to invalid.
     */
    invalid: BooleanConstructor;
    /**
     * Add a caption for a component.
     *
     * @since 4.3.0
     */
    label: {
        type: StringConstructor;
    };
    /**
     * The default name for a value passed using v-model.
     */
    modelValue: {
        type: (NumberConstructor | StringConstructor | {
            new (fileBits: BlobPart[], fileName: string, options?: FilePropertyBag | undefined): File;
            prototype: File;
        } | {
            new (value?: any): {
                constructor: Function;
                toString(): string;
                toLocaleString(): string;
                valueOf(): Object;
                hasOwnProperty(v: PropertyKey): boolean;
                isPrototypeOf(v: Object): boolean;
                propertyIsEnumerable(v: PropertyKey): boolean;
            };
            getPrototypeOf(o: any): any;
            getOwnPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined;
            getOwnPropertyNames(o: any): string[];
            create(o: object | null): any;
            create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;
            defineProperty<T>(o: T, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): T;
            defineProperties<T_1>(o: T_1, properties: PropertyDescriptorMap & ThisType<any>): T_1;
            seal<T_2>(o: T_2): T_2;
            freeze<T_3 extends Function>(f: T_3): T_3;
            freeze<T_4 extends {
                [idx: string]: object | U | null | undefined;
            }, U extends string | number | bigint | boolean | symbol>(o: T_4): Readonly<T_4>;
            freeze<T_5>(o: T_5): Readonly<T_5>;
            preventExtensions<T_6>(o: T_6): T_6;
            isSealed(o: any): boolean;
            isFrozen(o: any): boolean;
            isExtensible(o: any): boolean;
            keys(o: object): string[];
            keys(o: {}): string[];
            assign<T_7 extends {}, U_1>(target: T_7, source: U_1): T_7 & U_1;
            assign<T_8 extends {}, U_2, V>(target: T_8, source1: U_2, source2: V): T_8 & U_2 & V;
            assign<T_9 extends {}, U_3, V_1, W>(target: T_9, source1: U_3, source2: V_1, source3: W): T_9 & U_3 & V_1 & W;
            assign(target: object, ...sources: any[]): any;
            getOwnPropertySymbols(o: any): symbol[];
            is(value1: any, value2: any): boolean;
            setPrototypeOf(o: any, proto: object | null): any;
            values<T_10>(o: {
                [s: string]: T_10;
            } | ArrayLike<T_10>): T_10[];
            values(o: {}): any[];
            entries<T_11>(o: {
                [s: string]: T_11;
            } | ArrayLike<T_11>): [string, T_11][];
            entries(o: {}): [string, any][];
            getOwnPropertyDescriptors<T_12>(o: T_12): { [P in keyof T_12]: TypedPropertyDescriptor<T_12[P]>; } & {
                [x: string]: PropertyDescriptor;
            };
            fromEntries<T_13 = any>(entries: Iterable<readonly [PropertyKey, T_13]>): {
                [k: string]: T_13;
            };
            fromEntries(entries: Iterable<readonly any[]>): any;
        })[];
        default: undefined;
    };
    /**
     * Render the component styled as plain text. Removes the default form field styling and preserve the correct margin and padding. Recommend to use only along side `readonly`.
     */
    plainText: {
        type: BooleanConstructor;
        required: false;
    };
    /**
     * Toggle the readonly state for the component.
     */
    readonly: {
        type: BooleanConstructor;
        required: false;
    };
    /**
     * Size the component small or large.
     *
     * @values 'sm' | 'lg'
     */
    size: {
        type: StringConstructor;
        validator: (value: string) => boolean;
    };
    /**
     * Add helper text to the component.
     *
     * @since 4.3.0
     */
    text: {
        type: StringConstructor;
    };
    /**
     * Display validation feedback in a styled tooltip.
     *
     * @since 4.3.0
     */
    tooltipFeedback: BooleanConstructor;
    /**
     * Specifies the type of component.
     *
     * @values 'color' | 'file' | 'text' | string
     */
    type: {
        type: StringConstructor;
        default: string;
    };
    /**
     * Set component validation state to valid.
     */
    valid: BooleanConstructor;
}>> & {
    onChange?: ((...args: any[]) => any) | undefined;
    "onUpdate:modelValue"?: ((...args: any[]) => any) | undefined;
    onInput?: ((...args: any[]) => any) | undefined;
}, {
    type: string;
    invalid: boolean;
    disabled: boolean;
    valid: boolean;
    tooltipFeedback: boolean;
    modelValue: string | number | {
        constructor: Function;
        toString(): string;
        toLocaleString(): string;
        valueOf(): Object;
        hasOwnProperty(v: PropertyKey): boolean;
        isPrototypeOf(v: Object): boolean;
        propertyIsEnumerable(v: PropertyKey): boolean;
    } | File;
    plainText: boolean;
    readonly: boolean;
}>;
export { CFormInput };
